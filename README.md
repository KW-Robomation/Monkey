# Plutto Path 구조 및 처리

## 1. 개요

본 문서는 로봇팔 시뮬레이터 프로젝트 **Plutto**의 통신용 데이터인 **Plutto Path**에 대한 정의 및 변환 방식을 설명합니다.

Plutto Path는 SVG 경로 파싱 후 생성되는 로봇팔 관절 움직임 정보(JSON)를 **1바이트**로 압축하여, 하드웨어와의 효율적인 시리얼 통신을 목적으로 합니다.

### 1.1. 기존 JSON 방식의 한계

초기 로봇팔의 움직임 정보는 SVG 경로 파싱 후 다음과 같은 JSON 배열 형태로 생성되었습니다.


``` javascript 
[
  {"d1": -7, "d2": 3, "pen": 0}, // "d1" : -7은 다음 도달지점까지 joint1이 -7step (약 -(0.010986328 * 7) 도) 움직여야 함을 의미합니다. 
  {"d1": -7, "d2": 2, "pen": 0}, // "d2" : 2은 다음 도달지점까지 joint2가 -7step (약 (0.010986328 * 2) 도) 움직여야 함을 의미합니다. 
  {"d1": -7, "d2": 3, "pen": 0}  // "pen" : 0은 pen이 종이에 붙지 않는 상태로 이동해야 함을 나타냅니다.("pen" : 1 시 펜이 종이에 붙어있는 상태로 이동함을 의미합니다.
]
```
하지만 문자열 기반의 JSON 포맷은 매우 비효율적이고, 실제 필요한 정보($d1$: 4bits, $d2$: 4bits, $pen$: 1bit)를 인코딩하더라도 최소 9비트가 필요하므로 2바이트의 메모리가 요구됩니다.


### 1.2. Plutto Path의 도입 및 목표
Plutto Path는 이러한 비효율성을 해소하고 하드웨어 통신의 속도와 메모리 효율성을 극대화하기 위해 도입되었습니다. 목표는 모든 명령을 1바이트 크기의 배열로 압축하는 것입니다.
- 변환 전: ```[{"d1":-7,"d2":3,"pen":0}, ... ]```
- 변환 후: ```["0x93", ... ]```

## 2. Plutto Path 자료형 구조

Plutto Path는 **1Byte** 크기의 숫자를 원소로 하는 **1차원 배열** 형태의 자료형입니다. 배열의 각 원소는 다음 두 가지 정보를 담고 있습니다.

1.  **동작 명령 :** 두 관절의 동작 변화량 ($d1$, $d2$)
2.  **펜 상태 변경 명령 :** 펜의 Up/Down 상태 정보

### 2.1. 동작 명령 (Delta Byte) 구조

Delta Byte는 두 관절의 움직임 변화량($d1, d2$)을 담고 있습니다. 1바이트는 두 개의 4비트(니블, Nibble)로 나뉘어 다음과 같이 관절 변화량을 할당합니다.

* **High Nibble (상위 4비트):** 관절 1의 스텝 변화량 ($d1$)을 인코딩합니다.
* **Low Nibble (하위 4비트):** 관절 2의 스텝 변화량 ($d2$)을 인코딩합니다.

$$ \text{Byte} = (d1 \text{ Nibble} \ll 4) \mid d2 \text{ Nibble} $$

### 2.2. 펜 상태 변경 명령 (Control Byte)

동작 변화 인코딩에 사용되지 않는 특정 값을 **펜 상태 변경을 위한 제어 명령**으로 예약합니다. 이는 $d1$ 또는 $d2$의 4비트를 인코딩 시 **$0b1000$ (8)** 값이 사용되지 않는다는 점을 활용합니다.

| 1바이트 값 | 16진수 | 2진수 (8비트) | 의미 |
| :---: | :---: | :---: | :---: |
| **Pen Down** | $0\text{x}80$ | $1000\ 0000$ | 펜을 내립니다. |
| **Pen Up** | $0\text{x}08$ | $0000\ 1000$ | 펜을 올립니다. |

## 3. 인코딩/디코딩 방식

### 3.1. 4비트 인코딩 맵 ($d \rightarrow \text{Nibble}$)

관절 스텝 변화량 $d$는 $\mathbf{-7}$부터 $\mathbf{+7}$까지의 범위로 제한되며, 각 값은 다음의 4비트 이진수로 매핑됩니다.

| $\mathbf{d}$ 값 (10진수) | 4비트 이진수 (Nibble) | $\mathbf{d}$ 값 (10진수) | 4비트 이진수 (Nibble) |
| :---: | :---: | :---: | :---: |
| $\mathbf{-7}$ | $0b1001$ | $\mathbf{0}$ | $0b0000$ |
| $\mathbf{-6}$ | $0b1010$ | $\mathbf{1}$ | $0b0001$ |
| $\mathbf{-5}$ | $0b1011$ | $\mathbf{2}$ | $0b0010$ |
| $\mathbf{-4}$ | $0b1100$ | $\mathbf{3}$ | $0b0011$ |
| $\mathbf{-3}$ | $0b1101$ | $\mathbf{4}$ | $0b0100$ |
| $\mathbf{-2}$ | $0b1110$ | $\mathbf{5}$ | $0b0101$ |
| $\mathbf{-1}$ | $0b1111$ | $\mathbf{6}$ | $0b0110$ |
| | | $\mathbf{7}$ | $0b0111$ |

### 3.2. Plutto Path 생성 순서 (인코딩)

1.  **펜 상태 변화 감지:** 현재 명령의 `pen` 상태가 이전 명령과 다를 경우, 해당 펜 상태 변경을 위한 **Control Byte**($0\text{x}80$ 또는 $0\text{x}08$)를 먼저 배열에 추가합니다.
2.  **동작 명령 변환:** $d1$과 $d2$ 값을 4비트 인코딩 맵을 사용하여 각각 `High Nibble`과 `Low Nibble`로 변환합니다.
3.  **1바이트 구성:** $(high \ll 4) \mid low$ 연산을 통해 $d1$과 $d2$를 담은 **Delta Byte**를 배열에 추가합니다.

### 3.3. Plutto Path 해석 순서 (디코딩)

1.  **바이트 순회:** 배열의 각 바이트 $B$를 순서대로 확인합니다.
2.  **제어 명령 처리:**
    * $B = 0\text{x}80$: 현재 펜 상태를 Down (1)으로 갱신합니다.
    * $B = 0\text{x}08$: 현재 펜 상태를 Up (0)으로 갱신합니다.
3.  **동작 명령 해석:**
    * $B$가 제어 명령이 아닌 경우, $d1$ (High Nibble)과 $d2$ (Low Nibble)를 4비트 디코딩 맵을 사용하여 역변환합니다.
    * 해석된 $d1, d2$와 현재 펜 상태를 포함하는 모션 명령을 JSON 배열에 추가합니다.
